#######################################################
#
# Test checking if a key-value pair is present in a section file
#
#######################################################

bundle common acc_path
{
  vars:
    "root" string => getenv("NCF_TESTS_ACCEPTANCE", 1024);
}

body common control
{
      inputs => { "${acc_path.root}/default.cf.sub", "${acc_path.root}/default_ncf.cf.sub", "@{ncf_inputs.default_files}" };
      bundlesequence  => { default("${this.promise_filename}") };
      version => "1.0";
}

#######################################################
bundle agent init
{
  vars:
    "tmp"             string => getenv("TEMP", 1024);
    
    
  
    ## REPAIRED
    # ensure that a line is really added into the right section
    # with lines already present.
    "file[0]"     string => "${tmp}/test0.ini";
    "section[0]"  string => "section_test1";
    "name[0]"     string => "name1";
    "value[0]"    string => "value1";
    "section[0]"  string => "section_test1";
    "status[0]"   string => "repaired";
    "initial[0]"  string => "[section_test1]
[section_test2]";
    "expected[0]" string => "[section_test1]
${name[0]}=${value[0]}
[section_test2]";

    #  ensure that if the section does not exist, it will be created
    "file[1]"     string => "${tmp}/test1.ini";
    "section[1]"  string => "section_test1";
    "name[1]"     string => "name1";
    "value[1]"    string => "value1";
    "section[1]"  string => "section_test1";
    "status[1]"   string => "repaired";
    "initial[1]"  string => "[section_test2]";
    "expected[1]" string => "[section_test1]
${name[1]}=${value[1]}
[section_test2]";


    # ensure that if the value is modified if necessary
    "file[2]"     string => "${tmp}/test2.ini";
    "section[2]"  string => "section_test2";
    "name[2]"     string => "name2";
    "value[2]"    string => "value2";
    "section[2]"  string => "section_test2";
    "status[2]"   string => "repaired";
    "initial[2]"  string => "[section_test2]
name2=value";
    "expected[2]" string => "[section_test2]
${name[2]}=${value[2]}";

    # ensure that if the value is modified if necessary
    # but only in the selected region
    "file[3]"     string => "${tmp}/test3.ini";
    "section[3]"  string => "section_test3";
    "name[3]"     string => "name3";
    "value[3]"    string => "key?value3";
    "section[3]"  string => "section_test3";
    "status[3]"   string => "repaired";
    "initial[3]"  string => "[section_test3]
${name[3]}=key?value
[section_dummy]
${name[3]}=value";
    "expected[3]" string => "[section_test3]
${name[3]}=${value[3]}
[section_dummy]
${name[3]}=value";

    # ensure that if the value is modified if necessary
    # but only in the selected region
    # with = sign in value
    "file[4]"     string => "${tmp}/test4.ini";
    "section[4]"  string => "section_test4";
    "name[4]"     string => "name4";
    "value[4]"    string => "key=value4";
    "section[4]"  string => "section_test4";
    "status[4]"   string => "repaired";
    "initial[4]"  string => "[section_test4]
${name[4]}=key=value
[section_dummy]
${name[4]}=key";
    "expected[4]" string => "[section_test4]
${name[4]}=${value[4]}
[section_dummy]
${name[4]}=key";

    # KEPT
    # ensure that if the value is NOT modified
    # but only in the selected region
    # with = sign in value
    "file[5]"     string => "${tmp}/test5.ini";
    "section[5]"  string => "section_test5";
    "name[5]"     string => "name5";
    "value[5]"    string => "http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=BaseOS&infra=$infra";
    "section[5]"  string => "section_test5";
    "status[5]"   string => "success";
    "initial[5]"  string => "[section_test5]
${name[5]}=${value[5]}
[section_dummy]
${name[5]}=key";
    "expected[5]" string => "${initial[5]}";

    # Repaired
    # ensure that if the value is uncommenter
    # but only in the selected region
    # with = sign in value
    "file[6]"     string => "${tmp}/test6.ini";
    "section[6]"  string => "section_test6";
    "name[6]"     string => "name6";
    "value[6]"    string => "http://mirrorlist.centos.org/?release=$releasever&arch=$basearch&repo=BaseOS&infra=$infra";
    "section[6]"  string => "section_test6";
    "status[6]"   string => "repaired";
    "initial[6]"  string => "[section_test6]
#${name[6]}=${value[6]}
[section_dummy]
${name[6]}=key";
    "expected[6]" string => "[section_test6]
${name[6]}=${value[6]}
[section_dummy]
${name[6]}=key";
    
  "indices"     slist => getindices("status");

  files:
    "${file[${indices}]}"
      create => "true",
      edit_line => insert_lines("${initial[${indices}]}"),
      edit_defaults => empty,
      unless => strcmp("${indices}", "10");
}

#######################################################

bundle agent test
{
  vars:
    "args${init.indices}" slist => { "${init.file[${init.indices}]}", "${init.section[${init.indices}]}", "${init.name[${init.indices}]}", "${init.value[${init.indices}]}"};

  methods:
    # Enforce
    "ph0" usebundle  => apply_gm("file_key_value_present_in_ini_section", @{args0}, "${init.status[0]}", "ph0", "enforce" );
    "ph1" usebundle  => apply_gm("file_key_value_present_in_ini_section", @{args1}, "${init.status[1]}", "ph1", "enforce" );
    "ph2" usebundle  => apply_gm("file_key_value_present_in_ini_section", @{args2}, "${init.status[2]}", "ph2", "enforce" );
    "ph3" usebundle  => apply_gm("file_key_value_present_in_ini_section", @{args3}, "${init.status[3]}", "ph3", "enforce" );
    "ph4" usebundle  => apply_gm("file_key_value_present_in_ini_section", @{args4}, "${init.status[4]}", "ph4", "enforce" );
    "ph5" usebundle  => apply_gm("file_key_value_present_in_ini_section", @{args5}, "${init.status[5]}", "ph5", "enforce" );
    "ph6" usebundle  => apply_gm("file_key_value_present_in_ini_section", @{args6}, "${init.status[6]}", "ph6", "enforce" );
}

#######################################################

bundle agent check
{
  vars:
    pass1::
      "indices" slist => { @{init.indices} };
      
      # function readfile adds an extra trailing newline if there is no trailing newline, too inconsistent
      "content[${indices}]" string => execresult("${paths.cat} ${init.file[${indices}]}", "noshell"),
                            unless => strcmp("${indices}", "10");

  classes:
      "pass3" expression => "pass2";
      "pass2" expression => "pass1";
      "pass1" expression => "any";

    pass2::
      # file 10 is non existant
      "content_ok_${indices}" expression => and(
                                            strcmp("${content[${indices}]}", "${init.expected[${indices}]}"),
                                            fileexists("${init.file[${indices}]}")
                                          ),
                                  unless => strcmp("${indices}", "10");
      "content_ok_10" expression => "any";

      "content_not_ok" expression => "!content_ok_${indices}";
      "classes_ok"     expression => "ph0_ok.ph1_ok.ph2_ok.ph3_ok.ph4_ok.ph5_ok.ph6_ok";
      "ok"             expression => "!content_not_ok.classes_ok";


  reports:
    pass3::
      "###########################
ERROR test ${indices} in
${init.file[${indices}]}
EXPECTED:
${init.expected[${indices}]}
---------------------------
FOUND:
${content[${indices}]}
###########################"
         ifvarclass => "!content_ok_${indices}";

    pass3.ok::
      "$(this.promise_filename) Pass";
    pass3.!ok::
      "$(this.promise_filename) FAIL";
}
